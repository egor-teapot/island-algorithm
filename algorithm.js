const test1 = [ // 4 острова
    [0, 1, 1, 0, 0, 0, 0, 0, 0, 0,],
    [0, 1, 1, 0, 0, 1, 0, 0, 0, 0,],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0,],
    [0, 1, 1, 1, 0, 0, 0, 0, 0, 0,],
    [1, 1, 1, 1, 1, 0, 0, 0, 0, 0,],
    [0, 0, 1, 0, 1, 0, 0, 0, 0, 0,],
    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0,],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0,],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0,]
]

const test2 = [ // 2 острова
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0,],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0,],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0,],
    [0, 0, 1, 1, 1, 1, 1, 0, 0, 0,],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0,],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0,],
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0,],
    [0, 0, 1, 1, 1, 1, 1, 1, 0, 0,],
    [0, 0, 1, 0, 1, 0, 1, 1, 0, 0,],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]
]

const islandAlgorithm2 = (arr) => {
    let count = 0 // создаем счетчик
    const colsL = arr[0].length  // узнаем длину подмассива
    const rowsL = arr.length // узнаем колличество подмассивов

    // проверка если колличество подмассивов = 0 завершаем функцию
    if(rowsL === 0) return count

    // рекурсивная функция которая отмечает каждую землю в попавшемся острове
    const markLand = (arr, row, col) => {
        arr[row][col] = 3

        if(arr[row][col-1] === 1) markLand(arr, row, col-1)
        if(arr[row][col+1] === 1) markLand(arr, row, col+1)

        /*       либо можно сделать так
        if(arr[row-1] && arr[row-1][col] === 1) markLand(arr, row-1, col)
        if(arr[row+1] && arr[row+1][col] === 1) markLand(arr, row-1, col)   */
        if(arr?.[row-1]?.[col] === 1) markLand(arr, row-1, col)
        if(arr?.[row+1]?.[col] === 1) markLand(arr, row+1, col)

        /*
            Когда я пытался решить задачку сам, у меня была мысть по
            типу "можно просмотреть сразу все острова..." Но как?
            На тот момент я знал как использовать рекурсии, но какой
            мощью они обладают я и не подозревал!

            Происходит это примерно так. функция получает на вход
            массив, на каком подмассиве и на каком элементе подмассива
            находится.

            Она помечает место изученым на котором она находится,
            затем функция вызывает сама себя для каждого верхнего, правого,
            нижнего и левого элемента, помечает каджый элемент И 
            вызывает сама себя для каждого верхнего, правого,
            нижнего и левого предыдущих переданных элементов.

            Если предсавлять это более визуально, то от точки
            соприкосновения с "островом" идет волна которая
            проходится по каждой земле этого острова.

            Алгоритмы это чортово колдунство и мне это нравится!
        
        */
    } // markLand

    for(let R=0; R < rowsL; R++) { // прохидится по каждому подмассиву
        for(let C=0; C < colsL; C++) { // проходится по каждому элементу подмассива

            if(arr[R][C] === 1) {
                count++ // записывает найденный остров
                // помечает каждую землю острова, что бы не произошло пересчета
                markLand(arr, R, C) 
            }

        } // for C
    } // for R

    console.log(arr)
    return count // выводит количество встреченных островов
}

console.log(islandAlgorithm2(test2))

// console.log(test1.length)